package com.lhsystems.module.datageneratorancillary.service;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.List;
import java.util.Random;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Class that randomly generates flights.
 *
 * @author REJ
 * @version $Revision: 1.10 $
 */
public final class FlightGenerator {

    /** The first date of the generation interval. */
    private final LocalDate minDate;

    /** The last date of the generation interval. */
    private final LocalDate maxDate;

    /**
     * Generates a stream of pseudorandom numbers used for generating flights.
     */
    private final Random random = new Random();

    /**
     * Counter to remember which numbers have been used as <code>id</code>
     * already.
     */
    private long idCounter;

    /**
     * Counter to remember which numbers have been used as
     * <code>flightNumber</code> already.
     */
    private int flightNumberCounter;

    /**
     * list of <code>airport</code> objects to be used for the generation of
     * flights.
     */
    private final List<Airport> airports;

    /**
     * Constructor.
     *
     * @param startId
     *            a lower bound for the numbers used to compute the Ids of
     *            flights
     * @param paramAirports
     *            list of airports to be used for flight generation
     * @param paramMinDate
     *            the first date of the generation interval
     * @param paramMaxDate
     *            the last date of the generation interval
     */
    public FlightGenerator(final long startId,
            final List<Airport> paramAirports,
            final LocalDate paramMinDate, final LocalDate paramMaxDate) {
        setIdCounter(startId);
        airports = paramAirports;
        minDate = paramMinDate;
        maxDate = paramMaxDate;
    }

    /**
     * This method generates a number of flights randomly and returns them in an
     * ArrayList. The flights are generated randomly according to
     * {@link FlightGenerator#generateFlight() 'generateFlight'}. In particular
     * the identifiers 'id' are selected such that they are unique for all
     * flights generated by this instance. The departure time and date are
     * chosen randomly. Origin and destination are chosen randomly from the keys
     * of the predefined ArrayList <code>AIRPORTS</code>. The larger one of the
     * corresponding <code>Markets</code> is chosen for the flight.
     *
     * @param numberOfFlights
     *            the number of flights to be generated
     * @return an ArrayList of flights
     */
    public List<Flight> generateFlights(final int numberOfFlights) {
        return Stream.iterate(0, n -> n + 1).limit(numberOfFlights).map(
                n -> generateFlight()).collect(Collectors.toList());
    }

    /**
     * Returns the constant HashMap <code>AIRPORTS</code>.
     *
     * @return the constant HashMap <code>AIRPORTS</code>
     */
    private List<Airport> getAirports() {
        return airports;
    }

    /**
     * {@see generateFlights()} for more details.
     *
     * @return a randomly generated flight
     */
    private Flight generateFlight() {
        final long id = increaseIdCounter();
        final int flightNumber = increaseFlightNumberCounter();
        // returns a Random Day of 2018 or 2019
        final LocalDate departureDate = getRandomDay();
        final LocalTime departureTime = getRandomDaytime();
        final Airport originAirport = getRandomAirport();
        final Airport destinationAirport = getDestinationAirport(originAirport);
        final Market market = originAirport.getMarket().getMaximumMarket(
                destinationAirport.getMarket());
        return new Flight(
                id,
                flightNumber,
                LocalDateTime.of(departureDate, departureTime),
                originAirport.getIata(),
                destinationAirport.getIata(),
                market);
    }

    /**
     * Returns a random <code>Airport</code> which is different from
     * <code>originAirport</code>.
     *
     * @param originAirport
     *            some <code>Airport</code>
     * @return destinationAirport which is different from originAirport
     */
    private Airport getDestinationAirport(final Airport originAirport) {
        Airport destinationAirport = getRandomAirport();
        while (originAirport == destinationAirport) {
            destinationAirport = getRandomAirport();
        }
        return destinationAirport;
    }

    /**
     * Returns the random number generator of this object.
     *
     * @return this.random
     */
    private Random getRandom() {
        return random;
    }

    /**
     * Returns a randomly chosen <code>Airport</code> out of
     * <code>AIRPORTS</code>.
     *
     * @return a randomly chosen <code>Airport</code> out of
     *         <code>AIRPORTS</code>
     */
    private Airport getRandomAirport() {
        return getAirports().get(getRandom().nextInt(getAirports().size()));
    }

    /**
     * Returns a randomly chosen <code>LocalDate</code> in the time interval
     * between <code>minDate</code> and <code>maxDate</code>.
     *
     * @return a randomly chosen <code>LocalDate</code> between
     *         <code>minDate</code> and <code>maxDate</code>
     */
    private LocalDate getRandomDay() {

        return LocalDate.ofEpochDay(
                minDate.toEpochDay()
                + getRandom().nextInt(
                        (int) (maxDate.toEpochDay()
                                - minDate.toEpochDay())));

    }

    /**
     * Returns a randomly generated <code>LocalTime</code>.
     *
     * @return a randomly generated <code>LocalTime</code>
     */
    private LocalTime getRandomDaytime() {
        return LocalTime.of(
                getRandom().nextInt((int) TimeUnit.DAYS.toHours(1)),
                getRandom().nextInt((int) TimeUnit.HOURS.toMinutes(1)));
    }

    /**
     * Returns the <code>flightNumberCounter</code> of this object and
     * increments it.
     *
     * @return <code>this.flightNumberCounter</code>
     */
    private int increaseFlightNumberCounter() {
        final int tempHelper = flightNumberCounter;
        this.setFlightNumberCounter(flightNumberCounter + 1);
        return tempHelper;
    }

    /**
     * Returns the current value of <code>idCounter</code> and increments it.
     *
     * @return the current value of <code>idCounter</code>
     */
    private Long increaseIdCounter() {
        final Long tempHelper = idCounter;
        setIdCounter(idCounter + 1);
        return tempHelper;
    }

    /**
     * Sets the current value of <code>idCounter</code> to the given number.
     *
     * @param paramIdCounter
     *            the number that <code>idCounter</code> is set to.
     */
    private void setIdCounter(final Long paramIdCounter) {
        idCounter = paramIdCounter;
    }

    /**
     * Sets the <code>flightNumberCounter</code> to a new number given by the
     * parameter.
     *
     * @param paramFlightNumberCounter
     *            the number that <code>flightNumberCounter</code> is set to.
     */
    private void setFlightNumberCounter(final int paramFlightNumberCounter) {
        flightNumberCounter = paramFlightNumberCounter;
    }

}
